<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>key-aggregation-based-scheme-for-ln-payments.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1>Introduction</h1>

<p>LN was designed before Schnorr signatures and multi party signature
protocols like MuSig were available on bitcoin.</p>

<p>How can we design LN with these new tools available to us?</p>

<p>What if we can do away with HTLCs completely by using signature
aggregation? If a protocol was possible what would look like and what
will be advantages and disadvantages of such a protocol over the
current HTLC based approach?</p>

<p>This document presents one possible construction that uses MuSig2
between multiple channels across parties to make reliable atomic
payments.</p>

<h1>Goals for any new construction</h1>

<ol>
<li>Payments should be <em>atomic</em> - either all parties update channel
state, or none do.</li>
<li>Payments should be <em>reliable</em> - either the sender receives a success
or a failure. That is, a sender is never left hanging about the
status of the payment.</li>
<li>Payments should be <em>synchronous</em> - payment processing should
complete in under seven seconds for the sender, or it should fail.</li>
<li>Payment should not leak information - i.e. payments should help
retain sender and receiver privacy - even from parties that forward
the payment.</li>
</ol>


<h1>Does LN currently provide the above goals?</h1>

<ol>
<li>We do get atomicity, but the time bounds are large due to inherent
time delays in HTLCs.</li>
<li>There are some corner cases where payments get stuck, so the
protocol misses providing reliability. This is caused
by timing dependencies HTLCs and need to broadcast transactions on
chain to unroll them in worse case.</li>
<li>Failure cases can not finish under seven seconds - again due to
timelocks.</li>
<li>LN can meet privacy challenge, as we move to taproot channels and
PTLC instead of HTLCs.</li>
</ol>


<p>The above unsolved problems in lightning come from the use of HTLCs to
forward payments along a path.</p>

<p>Going back to the question we posed at the start: Can we come up with
a construction using MuSig2 that meets our goals above?</p>

<h1>Protocol overview</h1>

<ol>
<li>Gossip and path finding algorithms are used as normal to get a list
of parties a payment will be forwarded through.</li>
<li>All parties along the channel along in the path then construct
transactions spending the channel commitment transaction outputs
into a construction that guarantees the following:

<ol>
<li>All parties will update their channel outputs, or no parties
will.</li>
<li>If a party tries to cheat by publishing an old state, the other
parties can take all the input amount of that party. [This can
be later replaced with any other covenant bitcoin adopts in the
future.]</li>
</ol>
</li>
<li>The sender initiates a key and signature algorithm to generate
signatures for the transactions generated in the last step.</li>
<li>Once all parties have signed the transactions, all parties can
update their channel state.</li>
</ol>


<p>The protocol does not require any changes to path finding, we still
need to know which nodes can help forward a payment from source to
destination.</p>

<p>Once this path is available, the protocol runs a key and signature
aggregation algorithms to provide atomic state change across all
channels. That is, all parties either change state to capture the
payment along the path or no party changes any state.</p>

<p>In contrast to HTLC based approach, this atomic state change does not
traverse the path unlocking commitment transactions one hop at a
time. Instead all parties immediately have access to latest commitment
transaction states as soon as the MuSig2 signature aggregation
protocol finishes across all parties.</p>

<p>The communication protocol used to run the MuSig2 signature
aggregation algorithm only requires communication using onion packets
and therefore, each party along the path only knows about one upstream
and one downstream party. No party knows who are the senders and
receivers of the payment based on looking at the payment communication
messages.</p>

<h1>Payment processing using signature aggregation</h1>

<p>We describe the protocol using a simple two hop example.</p>

<p>Say Alice wants to pay Carol 1 bitcoin through Bob. Say the initial
channel balances are:</p>

<p><code>
Alice (10) &lt;-&gt; Bob (5)
Bob (10) &lt;-&gt; Carol (5)
</code></p>

<p>We will use this example to describe the protocol.</p>

<h2>Transactions Tree</h2>

<p>Before we describe the protocol in the next sections, these are the
types of transactions we will be constructing and signing:</p>

<ol>
<li>FT - Funding Transaction - the usual two party channel funding
transaction.</li>
<li>GCT - Group Commitment Transaction - a commitment transaction that
can be spent only if signed by all parties in a payment path using
MuSig2 protocol. The transaction uses all the FTs as inputs.</li>
<li>CT - Channel Commitment Transaction - a commitment transaction
generating outputs for all participants with updated balances.</li>
<li>PT - Punishment Transaction - a multi output transaction that
punishes a cheating party by taking all their funds on their
balance and distributing them to all other parties in the payment
path.</li>
<li>RK - Revocation Key - The revocation keys of all the rest of the
parties along a path to punish a party that broadcasts an old GCT.</li>
</ol>


<p>The figure below shows how the transactions are constructed as and we
explain these in the next sections.</p>

<p><img src="./commit-transactions.png" width="600px" /></p>

<h2>Setup</h2>

<ol>
<li>Channels are constructed using the funding transactions as per LN
BOLTs.</li>
<li>A payment route is found using any of the path finding
algorithms. Say the path is Alice -> Bob -> Carol.</li>
<li>MuSig2 nonce setup: Without going into details, we simply say here
that all the required public keys and nonces are shared between all
participants in the payment path during this setup phase. We
describe which combinations of keys and nonces are required in the
following steps.</li>
</ol>


<h2>Execution</h2>

<ol>
<li><strong>Key Aggregation</strong>:

<ol>
<li>Alice initiates the MuSig2 key aggregation protocol between the
three parties on the payment path. Let&rsquo;s call the resulting key
the &ldquo;group key&rdquo;.</li>
<li>All parties also generate MuSig2 aggregate keys for all
C(n,n-1), i.e. n combinations of parties. These are used for
discouraging parties from broadcasting old commitment
transactions as we will see next. We call these keys the
<strong>revocation keys</strong>.

<ol>
<li>The revocation key on party&rsquo;s branch (say A&rsquo;s) is essentially
the aggregated key of all parties bar A&rsquo;s.</li>
<li>This combinatorial number of keys limits how big n can be.</li>
</ol>
</li>
</ol>
</li>
<li><strong>Commitment transactions</strong>

<ol>
<li>All parties create commitment transactions that spend the
funding transaction output of all the channels. We call these
transactions the &ldquo;group commitment transactions&rdquo; (GCT). This GCT
is built using the punishment approach for providing covenants
and this can be simplified once another covenant op code is
enabled for bitcoin. For the current state of affairs on
bitcoin, the GCT has the following two outputs:

<ol>
<li>One spendable by the group key encumbered by a CSV and a hash
that only the party creating the commitment transaction knows
the pre-image of.</li>
<li>The other one is spendable by a revocation key that allows
all the other parties in the channel to spend this group
commitment transaction if they know the hash in
output 1. There is no CSV encumbrance here.</li>
</ol>
</li>
<li>The parties also create a &ldquo;channel commitment transaction&rdquo; (CT)
that spends the first output of the GCT with two outputs similar
to the LN BOLT commitment transactions, where <code>to_local</code> is
encumbered with a CSV delay and outputs for all other parties
are not encumbered with CSV.</li>
</ol>
</li>
<li><strong>Signing Commitment Transactions</strong>

<ol>
<li>All parties share their commitment transaction with all other
parties. We follow the broadcast protocol described in the next
section for all parties to share GCT and to generate aggregate
signatures.</li>
<li>When a party receives a commitment transaction of another party,
it verifies the structure out of the outputs, generates its
share of the MuSig2 signature follow the broadcast protocol to
share their share of the signature.</li>
</ol>
</li>
<li>Once a commitment transaction is signed, any party that broadcasts
an older commitment transaction will lose all their funds to all
the other members participating in the payment. The distribution of
the cheating party&rsquo;s funds is in proportion to the channel capacity
used by each funding party. We use this simple approach in the
transaction tree diagram above.

<ol>
<li>With covenant innovation, such a punishment scheme won&rsquo;t be
required.</li>
</ol>
</li>
</ol>


<h1>Broadcast Protocol Over Onion Routes</h1>

<p>The sequence diagram next shows how the parties interact to collect
required nonces and signature contributions. The sequence diagram
shows the simplicity of the protocol.</p>

<p><img src="./object-interaction.png" alt="object-interaction" /></p>

<h1>Analysis</h1>

<h2>Happy path - All Parties Sign</h2>

<p>All parties receive the aggregate signature for the group
key commitment transaction.</p>

<p>In this case, all parties know they can receive their correct amount
by broadcasting the new commitment transaction and the group
commitment transaction for their channel.</p>

<p>Knowing they are assured the can collect their correct balances
anytime by broadcasting the GCT and the CT. The parties can then
settle these commitment transactions by using the updated channel
balances to create new commitment transactions for new payments.</p>

<h2>Happy path - All Parties Sign - But One Cheats</h2>

<p>All parties sign the group commitment transaction, but a party tries
to broadcast an older channel commitment transaction. In this case,
any participant can broadcast the punishment transaction for the
CT. This will distribute the cheating party&rsquo;s balance to all other
parties in proportion to their balance.</p>

<h2>Unhappy path - Group Signing Fails or Party Broadcast Old Group Commitment</h2>

<p>In this case nothing changes and parties can create new group
commitment transactions for new payments.</p>

<p>If a party tries broadcasting an older group commitment transaction,
then all other parties can immediately take all the balance of the
cheating party by broadcasting the punishment transaction.</p>

<h1>Advantages</h1>

<ol>
<li>We reduce the attack surface where HTLCs are forwarded and unwound
back along the path.</li>
<li>Payments are atomic without additional protocol to confirm payments
along a path by revealing HTLCs. Either all parties agree or they
don&rsquo;t agree, no party can stall progress by choosing to losing
money.</li>
<li>Simplicity of commitment transaction construction. There are no
HTLCs and therefore the complexity of the commitment transactions
is reduced.</li>
</ol>


<h1>Disadvantages</h1>

<ol>
<li>Gathering signature for commitment transactions requires O(n<sup>2</sup>)
communication messages. The question here is how long are payment
paths in practice in LN at the moment? This protocol will
encourages higher connectivity between LN nodes so that payment
paths remain short.</li>
<li>The protocol requires all parties in the path to know about all the
participants included in the path.</li>
</ol>


<h1>Questions and Required Work</h1>

<ol>
<li>What is the payment length in real world usage? How long a path can
we support given a target transaction size.</li>
<li>Is there a smarter way to replace &ldquo;revocation keys&rdquo;?</li>
<li>What is the latency to run MuSig2 for a N parties over a p2p
network? We should assume all parties along a path can talk to each
other, even if they don&rsquo;t channels to each other.</li>
<li>How open are people to an alternative solution that does away with
onion routing for increase reliability of payments?</li>
<li>How much worse will the latency be compared to current protocol?</li>
<li>How do we scale this construction so that each channel can
simultaneously participate in more than one payment? The payments
will succeed or fail using this construction within much shorter
time periods - but these latencies have to be worked - and will
they be enough?</li>
</ol>


</body>
</html>
